<!DOCTYPE html>
<html>
  <head>
    <title>Roulette Tree</title>
    <link href='http://fonts.googleapis.com/css?family=Merriweather+Sans:300' rel='stylesheet' type='text/css'>
    <link href="css/main.css" rel="stylesheet" type="text/css">
    <script type="text/javascript"
            src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
   <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-26233521-2', 'hypirion.github.io');
      ga('send', 'pageview');

    </script>
  </head>
  <body>
    <div id="wrapper">
      <div id="content">
        <h1>Roulette Tree</h1>
        <p>A roulette tree (<em>rtree</em>) is a data structure aimed to speed
          up selection phases in evolutionary algorithms, specifically when one
          pick individuals for a new generation based upon fitness-proportionate
          selection methods. It is asymptotically better than current solutions,
          and will consequently run faster for large populations.
        </p>

        <h3>Quickstart</h3>
        <p>To build the rtree and see it in action, fetch the code from git and
        build the thing. Assuming you have <code>git</code>, <code>make</code>
        and <code>gcc</code>, you just have to do this:</p>
        <code><pre>git clone https://github.com/hyPiRion/roulette-tree.git rtree
cd rtree
make</pre></code>
        <p>To see an explanation on how it works, you can do as follows. This
        requires graphviz installed (more specifically, <code>dot</code>):</p>
        <code><pre>bin/main
cd imgs
make</pre></code>
        <p>A sequence of images from test-00 to test-11 should now have been
        generated. View them in sequence to "comprehend" what's going on.</p>

        <h2>The Problem</h2>
        <p>The general problem can be described as follows: You have a
        population of individuals, where you want to pick some percentage of the
        population based on how fit they are (their <em>fitness</em>). However,
        you would avoid picking a single individual multiple times, and you want
        to to have randomness so you don't always pick the top \(n\) best
        individuals all the time (to keep diversity in the population).</p>
        <p>As an example, let's say we have three different objects: \(A\),
        \(B\) and \(C\). \(fit(A)=3\), \(fit(B)=2\) and \(fit(C)=1\). Then, we
        want that, on average, \(A\) will be picked \(^3/_6\) of the time, \(B\)
        will be picked \(^2/_6\) of the time, and \(C\) will be picked \(^1/_6\)
        of the time.</p>
        <p>The way this is usually done is by simulating a roulette wheel: We
        list all the individuals we have, and let the individual hold a piece
        of the roulette wheel proportional to the individual's fitness. To pick
        an individual, we pick a random number and let the individual which
        contains the number in its fitness interval. See the figure below for
        an example.</p>
        <p style="text-align:center;"><img src="imgs/selection.png"
                                           alt="Example of Selection"/>
          <em>Example of selection.</em> </p>
        <p>The two standard ways of doing this sort of simulation is done by
        either using an <em>array</em>, or by using a <em>linked list</em>.</p>

        <h3>Linked List solution</h3>
        <p>The linked list solution is the easiest to understand conceptually.
        The structure is simply the total fitness score of the population, along
        witha linked list with the individuals and their fitness score, To
        randomly pick an individual, you pick a random number, \(d &lt;
        fit_{total}\) and iterate over the linked list. If the current
        individual's fitness is higher than \(d\), we pick the individual. If
        not, decrement \(d\) with the fitness of the individual and continue to
        next element. Now, if you want to remove the individual, you can do so
        while you're here (either by keeping track of the previous individual or
        by using a doubly linked list). Both operations take \(\mathcal{O}(n)\)
        time, which is not exactly good for large populations.</p>
        <p>Inserting an individual is easy and fast, however. Just put the
        individual as the first element in the list, and you're done. That
        takes \(\mathcal{O}(1)\) time.</p>

        <h3>Array-based solution</h3>
        <p>The array-based roulette utilizes binary searches to reduce the speed
        of random picks. We keep track of the total fitness score, and an array
        containing the cumulative fitness sum up to this individual, along with
        the individual itself.</p>
        <p>To perform a random pick, pick a random number \(d &lt; fit_{total}\)
        as before. Now, perform a binary search where you go <em>down</em> if
        \(d &lt; c\), where \(c\) is the cumulative sum at the current
        individual. If \(c \leq d &lt; (c + fit)\), we've found the individual
        we wanted to find. If \((c + fit) \leq d\), we go <em>up</em>. This
        gives us \(\mathcal{O}(\log n)\) in asymptotic runtime for random
        picks.</p>
        <p>Unfortunately, this is not sufficient for random pops: We must remove
        the individual, and update the new cumulative fitness for every element
        after the current one. This takes \(\mathcal{O}(n)\) time.</p>
        <p>If one double the capacity of the array whenever the capacity is
        filled, then adding a new element takes \(\mathcal{O}(1)\) amortized
        time.</p>

        <h3>Roulette tree</h3>
        <p>It is possible to improve the asymptotic time taken to randomly pop
        an element, at the expense of a slower insertion algorithm. This is
        what the <em>rtree</em> does: Sacrifices insertion speeds for increased
        random pops.</p>
        <p>The roulette tree is very complex compared to the other structures,
        but you can think of it as a red-black tree combined with a
        fenwick-tree. This makes both insertion, random picks and random pops
        take \(\mathcal{O}(\log n)\) time.</p>

        <h2>Comparison</h2>
        <p>Different needs for different people. If you need to repeatedly pop
        random individuals, I suggest going for the roulette tree. Otherwise,
        the array-based solution should handle most of your use cases. The
        linked list implementation is effectively useless, you can in all cases
        replace it with the array based one and get a speedup.</p>
        <table border="1">
          <tr>
            <th>Structure</th>
            <th>Add</th>
            <th>Pop</th>
            <th>Get</th>
          </tr>
          <tr>
            <td>Linked List</td>
            <td>\(\mathcal{O}(1)\)</td>
            <td>\(\mathcal{O}(n)\)</td>
            <td>\(\mathcal{O}(n)\)</td>
          </tr>
          <tr>
            <td>Array-based</td>
            <td>\(\mathcal{O}(1)\)</td>
            <td>\(\mathcal{O}(n)\)</td>
            <td>\(\mathcal{O}(\log n)\)</td>
          </tr>
          <tr>
            <td>Roulette tree</td>
            <td>\(\mathcal{O}(\log n)\)</td>
            <td>\(\mathcal{O}(\log n)\)</td>
            <td>\(\mathcal{O}(\log n)\)</td>
          </tr>
        </table>

        <h2>Further Work</h2>
        <p>Yeah, this sounds obviously more and more like some paper in a
        scientific journal. Let's not go into specific details, just explain
        that I'm aware of certain tricks to speed these structures up for
        certain use cases. We'll have a short look at the different
        possibilities.</p>
        <h3>Single-rpop roulette array</h3>
        <p>A single-rpop roulette array is a structure supporting
        \(\mathcal{O}(1)\) insertion times, and \(\mathcal{O}(\log n)\) random
        picks. It will also support a persistent random pop in
        \(\mathcal{O}(\log n)\) time, which will return the chosen individual,
        along with a roulette array where you can only perform random picks (in
        \(\mathcal{O}(\log n)\) time).</p>
        <h3>Fenwick-based roulette array</h3>
        <p>When you already know the size of the collection, the individuals
        and their fitness, you can speed up all the actions available. By
        removing the possibility to add in new elements after instantiation, we
        can get a \(\mathcal{O}(\log n)\) speed on random pops and random
        picks. The speed of construction will be \(\mathcal{O}(n\log n)\).</p>
        <p>Intially, this sounds like a rather useless idea: The asymptotic
        runtime doesn't even change! However, the constant is significantly
        reduced, and if you perform repeated rpops/rpicks without adding in new
        elements, this gives a significant speedup. Consequently, it speeds up
        the structure dramatically if you don't have to add in new individuals
        to the structure.</p>
        <h3>Sorted roulette trees</h3>
        <p>Sorted roulette trees will have the possibility to pick elements
        based upon their fitness. Such a tree will have the same properties as
        a <code>NavigableSet</code> and a <code>SortedSet</code> in Java, in
        \(\mathcal{O}(n\log n)\). The constant factor will be increased by a
        slight amount, but not considerably.</p>
        <h3>Persistent roulette trees</h3>
        <p>A persistent roulette tree will behave exactly as a normal roulette
        tree with the same asymptotic runtimes, but with a slightly higher
        constant factor. It will return persistent roulette trees, and will
        consequently be a tree usable in parallel. It may also implement the
        sorted roulette guarantees, again with a somewhat higher constant
        factor.</p>
      </div>
    </div>
  </body>
</html>
